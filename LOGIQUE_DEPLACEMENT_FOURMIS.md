# üêú Logique de D√©placement des Fourmis - Documentation Technique

## üìã Table des Mati√®res
1. [Vue d'Ensemble](#vue-densemble)
2. [Structure des Donn√©es](#structure-des-donn√©es)
3. [Algorithme Principal](#algorithme-principal)
4. [Fonctions de D√©cision](#fonctions-de-d√©cision)
5. [R√©solution de Conflits](#r√©solution-de-conflits)
6. [Syst√®me de Ph√©romones](#syst√®me-de-ph√©romones)
7. [Exemple d'Ex√©cution](#exemple-dex√©cution)
8. [Points Techniques](#points-techniques)

---

## üéØ Vue d'Ensemble

### Objectif Principal
Faire d√©placer toutes les fourmis du **Vestibule (Sv)** vers le **Dortoir (Sd)** en **minimisant le nombre d'√©tapes** tout en respectant les contraintes de capacit√© des salles.

### Strat√©gie Adopt√©e
- **Chemin le plus court** vers la destination
- **Priorit√© absolue** au dortoir si accessible
- **R√©solution intelligente des conflits** de capacit√©
- **Approche hybride** : simple + complexe selon les besoins

---

## üèóÔ∏è Structure des Donn√©es

### Classe `Ant` - Repr√©sentation d'une Fourmi
```python
@dataclass
class Ant:
    """Repr√©sente une fourmi avec son identifiant et sa position actuelle"""
    id: int              # Identifiant unique (1, 2, 3...)
    current_room: str    # Position actuelle ("Sv", "S1", "Sd"...)
    
    def __str__(self):
        return f"f{self.id}"
```

### Classe `AntColony` - Gestion de la Colonie
```python
class AntColony:
    def __init__(self, antnest):
        self.antnest = antnest                          # Structure de la fourmili√®re
        self.graph = self._create_graph()               # Graphe NetworkX des connexions
        self.ants = [Ant(i+1, "Sv") for i in range(antnest.ants)]  # Toutes les fourmis
        self.room_occupancy = self._init_room_occupancy()           # Occupation des salles
        self.step_count = 0                             # Compteur d'√©tapes
        self.movements_history = []                     # Historique des mouvements
        self.edge_passages = self._init_edge_passages() # Compteur de passages (ph√©romones)
```

### Structures de Suivi
```python
# Occupation des salles : {nom_salle: [liste_ids_fourmis]}
self.room_occupancy = {
    "Sv": [1, 2, 3, 4, 5],    # 5 fourmis au vestibule
    "S1": [],                  # Salle vide
    "S2": [6],                 # 1 fourmi dans S2
    "Sd": [7, 8]               # 2 fourmis arriv√©es
}

# Passages sur les ar√™tes : {(salle1, salle2): nombre_passages}
self.edge_passages = {
    ("S1", "Sv"): 12,         # 12 passages entre Sv et S1
    ("S1", "S2"): 8,          # 8 passages entre S1 et S2
    ("S2", "Sd"): 5           # 5 passages entre S2 et Sd
}
```

---

## üöÄ Algorithme Principal

### Fonction `simulate_step()` - C≈ìur de la Logique

Cette fonction simule **une √©tape compl√®te** de d√©placement de toutes les fourmis en utilisant une **approche hybride en 2 phases** :

```python
def simulate_step(self) -> List[Tuple[int, str, str]]:
    """Simule une √©tape de d√©placement - Version hybride optimis√©e"""
    movements = []
    
    # STRAT√âGIE HYBRIDE:
    # 1. Essayer d'abord l'approche simple (s√©quentielle) efficace
    # 2. Seulement si n√©cessaire, utiliser la r√©solution de conflits
    
    # Phase 1: Tentative d'approche s√©quentielle simple
    ants_needing_conflict_resolution = []
    temp_occupancy = {k: v.copy() for k, v in self.room_occupancy.items()}
    
    for ant in self.ants:
        if ant.current_room == "Sd":
            continue  # Fourmi d√©j√† arriv√©e
            
        available_moves = self._get_available_moves_with_temp(ant, temp_occupancy)
        
        if "Sd" in available_moves:
            # PRIORIT√â ABSOLUE pour aller au dortoir
            old_room = ant.current_room
            if self._can_move_immediately(ant, "Sd", temp_occupancy):
                movements.append((ant.id, old_room, "Sd"))
                self._update_temp_occupancy(ant, old_room, "Sd", temp_occupancy)
                self._record_edge_passage(old_room, "Sd")  # Ph√©romones
                ant.current_room = "Sd"
            else:
                ants_needing_conflict_resolution.append(ant)
        else:
            # Choisir le meilleur mouvement vers Sd
            best_move = self._choose_best_move_with_temp(ant, available_moves)
            if best_move and self._can_move_immediately(ant, best_move, temp_occupancy):
                old_room = ant.current_room
                movements.append((ant.id, old_room, best_move))
                self._update_temp_occupancy(ant, old_room, best_move, temp_occupancy)
                self._record_edge_passage(old_room, best_move)
                ant.current_room = best_move
            elif best_move:
                ants_needing_conflict_resolution.append(ant)
    
    # Phase 2: R√©solution de conflits pour les fourmis restantes
    if ants_needing_conflict_resolution:
        # ... r√©solution complexe des conflits ...
        
    self.room_occupancy = temp_occupancy
    self.step_count += 1
    self.movements_history.append(movements)
    return movements
```

#### üìä Phase 1 : Approche S√©quentielle
**Principe** : Traiter chaque fourmi dans l'ordre, en priorisant les mouvements simples sans conflit.

**Avantages** :
- ‚úÖ **Rapidit√©** : √âvite les calculs complexes pour 80% des cas
- ‚úÖ **Efficacit√©** : Priorit√© claire au dortoir
- ‚úÖ **Simplicit√©** : Logique directe et compr√©hensible

#### ‚öîÔ∏è Phase 2 : R√©solution de Conflits
**Principe** : Pour les fourmis qui ne peuvent pas bouger (conflits de capacit√©), utiliser un algorithme sophistiqu√©.

---

## üé™ Fonctions de D√©cision

### üö™ A. D√©termination des Mouvements Possibles

```python
def get_available_moves(self, ant: Ant) -> List[str]:
    """Retourne les salles o√π une fourmi peut se d√©placer"""
    current_room = ant.current_room
    available_rooms = []
    
    neighbors = list(self.graph.neighbors(current_room))  # Salles connect√©es par tunnels
    
    for room in neighbors:
        if room == "Sd":
            available_rooms.append(room)  # Dortoir = capacit√© ‚àû
        elif room in self.antnest.rooms:
            capacity = self.antnest.rooms[room]
            current_occupants = len(self.room_occupancy.get(room, []))
            if current_occupants < capacity:
                available_rooms.append(room)  # Salle pas pleine
        elif room == "Sv":
            available_rooms.append(room)  # Vestibule = capacit√© ‚àû
                
    return available_rooms
```

**Logique de Validation** :
- ‚úÖ **Dortoir (Sd)** ‚Üí Toujours accessible (capacit√© illimit√©e)
- ‚úÖ **Vestibule (Sv)** ‚Üí Toujours accessible (capacit√© illimit√©e)  
- ‚úÖ **Salle normale** ‚Üí Accessible SI `occupants_actuels < capacit√©`
- ‚ùå **Pas de tunnel** ‚Üí Inaccessible

### üß≠ B. Choix du Meilleur Mouvement

```python
def _choose_best_move_with_temp(self, ant, available_moves: List[str]) -> Optional[str]:
    """Choisit le meilleur mouvement pour se rapprocher du dortoir"""
    if not available_moves:
        return None
        
    best_move = None
    shortest_distance = float('inf')
    
    for move in available_moves:
        try:
            # Calculer la distance de graphe vers le dortoir
            distance = nx.shortest_path_length(self.graph, move, "Sd")
            if distance < shortest_distance:
                shortest_distance = distance
                best_move = move
        except nx.NetworkXNoPath:
            continue  # Pas de chemin possible, ignorer cette option
                
    return best_move
```

**Crit√®re de Choix** : **Distance minimale vers le dortoir** (algorithme de Dijkstra via NetworkX)

**Exemple** :
```
Fourmi en S1, mouvements possibles : [Sv, S2, S3]
- distance(Sv ‚Üí Sd) = 3 √©tapes
- distance(S2 ‚Üí Sd) = 1 √©tape  ‚Üê MEILLEUR CHOIX
- distance(S3 ‚Üí Sd) = 2 √©tapes
‚Üí Choisir S2
```

### üèÉ‚Äç‚ôÄÔ∏è C. Validation de Mouvement Imm√©diat

```python
def _can_move_immediately(self, ant, destination: str, temp_occupancy: dict) -> bool:
    """V√©rifie si une fourmi peut bouger imm√©diatement sans conflit"""
    if destination in ["Sd", "Sv"]:  # Capacit√© illimit√©e
        return True
    elif destination in self.antnest.rooms:
        capacity = self.antnest.rooms[destination]
        current_occupants = len(temp_occupancy.get(destination, []))
        return current_occupants < capacity
    return False
```

---

## ‚öîÔ∏è R√©solution de Conflits

### Probl√®me : Embouteillages
Plusieurs fourmis veulent aller dans la m√™me salle √† capacit√© limit√©e.

### Solution : `_resolve_movement_conflicts()`

```python
def _resolve_movement_conflicts(self, planned_moves) -> List[Tuple]:
    """R√©sout les conflits de mouvement et d√©tecte les √©changes simultan√©s"""
    valid_moves = []
    room_destinations = {}  # destination ‚Üí [fourmis qui veulent y aller]
    room_departures = {}    # salle ‚Üí [fourmis qui la quittent]
    
    # 1. ANALYSER tous les mouvements planifi√©s
    for ant, old_room, new_room in planned_moves:
        # Enregistrer les destinations
        if new_room not in room_destinations:
            room_destinations[new_room] = []
        room_destinations[new_room].append((ant, old_room, new_room))
        
        # Enregistrer les d√©parts
        if old_room not in room_departures:
            room_departures[old_room] = []
        room_departures[old_room].append((ant, old_room, new_room))
    
    # 2. TRAITER chaque destination
    for destination, moves_to_dest in room_destinations.items():
        if destination in ["Sd", "Sv"]:
            # Capacit√© illimit√©e : accepter tout le monde
            valid_moves.extend(moves_to_dest)
        elif destination in self.antnest.rooms:
            # Salle normale : calculer les places disponibles
            capacity = self.antnest.rooms[destination]
            current_occupants = len(self.room_occupancy.get(destination, []))
            
            # ASTUCE : Places qui se lib√®rent = fourmis qui partent
            departing_from_dest = len(room_departures.get(destination, []))
            available_spots = capacity - current_occupants + departing_from_dest
            
            # Accepter seulement les N premi√®res fourmis (ordre FIFO)
            valid_moves.extend(moves_to_dest[:available_spots])
    
    return valid_moves
```

### Exemple de R√©solution
```
Situation : S1 (capacit√©: 2, occupants: [f3, f4])
Mouvements planifi√©s :
- f1: Sv ‚Üí S1
- f2: Sv ‚Üí S1  
- f3: S1 ‚Üí S2
- f5: Sv ‚Üí S1

Calcul :
- current_occupants = 2
- departing_from_dest = 1 (f3 part)
- available_spots = 2 - 2 + 1 = 1 place

R√©sultat : Seulement f1 peut aller en S1 (FIFO)
```

**Avantage** : G√®re les **√©changes simultan√©s** intelligemment !

---

## üêú Syst√®me de Ph√©romones

### Enregistrement des Passages

```python
def _record_edge_passage(self, room1: str, room2: str):
    """Enregistre le passage d'une fourmi sur une ar√™te"""
    # Normaliser l'ordre pour √©viter (A,B) vs (B,A)
    edge = tuple(sorted([room1, room2]))
    if edge in self.edge_passages:
        self.edge_passages[edge] += 1  # +1 passage sur ce tunnel
```

### Calcul des Donn√©es Visuelles

```python
def get_pheromone_data(self) -> Dict[tuple, dict]:
    """Retourne les donn√©es de ph√©romones avec intensit√© normalis√©e"""
    if not self.edge_passages:
        return {}
        
    max_passages = max(self.edge_passages.values()) if self.edge_passages.values() else 1
    
    pheromone_data = {}
    for edge, passages in self.edge_passages.items():
        if passages > 0:  # Seulement les ar√™tes utilis√©es
            intensity = passages / max_passages  # Normalisation 0-1
            pheromone_data[edge] = {
                'passages': passages,
                'intensity': intensity,
                'width': 1 + intensity * 4,      # Largeur tunnel : 1-5px
                'alpha': 0.3 + intensity * 0.7   # Transparence : 30%-100%
            }
    return pheromone_data
```

### R√©sultat Visuel
- **Tunnels tr√®s utilis√©s** ‚Üí **√©pais et opaques** (violet fonc√©)
- **Tunnels peu utilis√©s** ‚Üí **fins et transparents** (violet clair)
- **Tunnels jamais utilis√©s** ‚Üí **noirs et fins**

---

## üìä Exemple d'Ex√©cution Compl√®te

### Configuration Initiale
```
Fourmili√®re : 3 fourmis, structure lin√©aire
Sv (‚àû) ‚Üê‚Üí S1 (cap:2) ‚Üê‚Üí S2 (cap:1) ‚Üê‚Üí Sd (‚àû)

√âtat initial :
- Sv: [f1, f2, f3]
- S1: []  
- S2: []
- Sd: []
```

### √âtape 1 : D√©placement Initial
```python
# f1 : available_moves = [S1]
# distance(S1 ‚Üí Sd) = 2
# S1 pas pleine (0/2) ‚Üí f1: Sv ‚Üí S1 ‚úÖ

# f2 : available_moves = [S1] 
# S1 pas pleine (1/2) ‚Üí f2: Sv ‚Üí S1 ‚úÖ

# f3 : available_moves = [S1]
# S1 pleine (2/2) ‚Üí f3 reste en Sv ‚ùå
```
**R√©sultat** : `Sv: [f3]`, `S1: [f1, f2]`, `S2: []`, `Sd: []`

### √âtape 2 : Progression vers le Dortoir
```python
# f1 : available_moves = [Sv, S2]
# distance(Sv ‚Üí Sd) = 3, distance(S2 ‚Üí Sd) = 1
# Choisir S2 ‚Üí f1: S1 ‚Üí S2 ‚úÖ

# f2 : available_moves = [Sv, S2]
# S2 pleine (1/1) ‚Üí choisir Sv ‚Üí f2: S1 ‚Üí Sv ‚úÖ

# f3 : available_moves = [S1]
# S1 a maintenant 0/2 ‚Üí f3: Sv ‚Üí S1 ‚úÖ
```
**R√©sultat** : `Sv: [f2]`, `S1: [f3]`, `S2: [f1]`, `Sd: []`

### √âtape 3 : Premi√®re Arriv√©e
```python
# f1 : available_moves = [S1, Sd]
# PRIORIT√â ABSOLUE au dortoir ‚Üí f1: S2 ‚Üí Sd ‚úÖ ARRIV√âE!

# f2 : available_moves = [S1]
# S1 pas pleine ‚Üí f2: Sv ‚Üí S1 ‚úÖ

# f3 : available_moves = [Sv, S2]  
# distance(S2 ‚Üí Sd) = 1 < distance(Sv ‚Üí Sd) = 3
# S2 libre ‚Üí f3: S1 ‚Üí S2 ‚úÖ
```
**R√©sultat** : `Sv: []`, `S1: [f2]`, `S2: [f3]`, `Sd: [f1]` ‚úÖ

### √âtapes Suivantes...
Le processus continue jusqu'√† ce que toutes les fourmis atteignent le dortoir.

### Statistiques Finales
```python
Passages enregistr√©s :
- (Sv, S1): 4 passages ‚Üí Tunnel √©pais, tr√®s utilis√©
- (S1, S2): 3 passages ‚Üí Tunnel moyen
- (S2, Sd): 3 passages ‚Üí Tunnel moyen
- (S1, Sv): 1 passage ‚Üí Tunnel fin (retour)

R√©sultat : Toutes les fourmis au dortoir en 6 √©tapes
```

---

## üéØ Points Techniques Avanc√©s

### üîß Optimisations Impl√©ment√©es

#### 1. **Occupation Temporaire**
```python
temp_occupancy = {k: v.copy() for k, v in self.room_occupancy.items()}
```
Permet de simuler les mouvements sans modifier l'√©tat r√©el, √©vitant les conflits de lecture/√©criture.

#### 2. **D√©tection de Blocage**
```python
def solve(self) -> List[List[Tuple[int, str, str]]]:
    while not self.all_ants_in_dormitory():
        movements = self.simulate_step()
        if not movements:  # Aucun mouvement possible
            print("‚ö†Ô∏è Blocage d√©tect√©, arr√™t de la simulation")
            break
```

#### 3. **Normalisation des Ar√™tes**
```python
edge = tuple(sorted([room1, room2]))  # (A,B) = (B,A)
```
√âvite de compter s√©par√©ment `(Sv, S1)` et `(S1, Sv)` dans les ph√©romones.

### üöÄ Complexit√© Algorithmique

- **Complexit√© temporelle** : O(n √ó m) par √©tape
  - n = nombre de fourmis
  - m = nombre moyen de voisins par salle
- **Complexit√© spatiale** : O(s + t)
  - s = nombre de salles
  - t = nombre de tunnels

### ‚ö° Performance

**Cas simples** (80% des situations) :
- Phase 1 seulement ‚Üí **Tr√®s rapide**
- Calcul direct, pas de r√©solution de conflit

**Cas complexes** (20% des situations) :
- Phase 1 + Phase 2 ‚Üí **Mod√©r√©ment rapide**
- R√©solution intelligente des embouteillages

### üîÑ Extensions Possibles

#### 1. **Strat√©gies Alternatives**
```python
# Actuellement : Plus court chemin
distance = nx.shortest_path_length(self.graph, move, "Sd")

# Possible : Moins d'embouteillages
congestion_factor = len(self.room_occupancy.get(move, [])) / capacity
score = distance + congestion_factor * 0.5
```

#### 2. **Priorit√©s Diff√©rentielles**
```python
# Actuellement : FIFO (First In, First Out)
valid_moves.extend(moves_to_dest[:available_spots])

# Possible : Priorit√© aux fourmis les plus √©loign√©es
moves_sorted = sorted(moves_to_dest, key=lambda x: distance_to_dormitory)
valid_moves.extend(moves_sorted[:available_spots])
```

#### 3. **M√©morisation des Chemins**
```python
# Possibilit√© d'ajouter une "m√©moire" des meilleurs chemins
self.successful_paths = {}  # fourmi_id ‚Üí liste des salles travers√©es
```

---

## üéØ Conclusion

Cette impl√©mentation offre un **√©quilibre optimal** entre :
- ‚úÖ **Simplicit√©** : Logique claire et compr√©hensible
- ‚úÖ **Efficacit√©** : Traitement rapide des cas courants
- ‚úÖ **Robustesse** : Gestion intelligente des cas complexes
- ‚úÖ **Visualisation** : Syst√®me de ph√©romones pour l'analyse
- ‚úÖ **Extensibilit√©** : Architecture modulaire pour futures am√©liorations

L'algorithme garantit que **toutes les fourmis atteignent le dortoir** en un **nombre minimal d'√©tapes** tout en respectant **rigoureusement les contraintes de capacit√©** des salles.

---

